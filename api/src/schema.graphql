type User {
  id: ID!
  first_name: String
  last_name: String
  email: String
  phone_number: String
  email_signature: String
  pswd: String
  created_date: String
  address:  Address @relation(name: "HAS_ADDRESS", direction: "OUT")
  follows: [User] @relation(name: "FOLLOWS", direction: "BOTH")
  teams:  [Team] @relation(name: "IS_MEMBER_OF", direction: "OUT")
  contacts:  [Contact] @relation(name: "OWNS_PROSPECT", direction: "OUT")
  listings:  [Listing] @relation(name: "IS_PRIMARY_AGENT_FOR", direction: "OUT")
}

type Deal {
    id: ID!
    title: String
    start_time: DateTime
    est_date: DateTime
    amount: String
    stage: String
    strategy: Strategy @relation(name: "HAS_STRATEGY", direction: "OUT")
    type: Type @relation(name: "HAS_TYPE", direction: "OUT")
    property:  Property @relation(name: "HAS_INTEREST_IN", direction: "OUT")
    client:  Client @relation(name: "HAS_INTEREST_IN", direction: "IN")
}

interface Client {
    id: ID!
    name: String
    email: String
    lead_status: String
    phone: String
    created_at: Date
    owner:  User @relation(name: "OWNS_PROSPECT", direction: "IN")
}

type Contact implements Client{

  id: ID!
  first_name: String
  last_name: String
  suffix: String
  birthday: String
  contact_emails: [String]
  email: String
  phone: String
  mobile: String
  phone_numbers: [String]
  linkedin_url: String
  facebook_url: String
  instagram_url: String
  twitter_url: String
  lead_status: String
  lead_type: String
  lead_date: String
  lifecycle_stage: String
  created_at: Date
  last_modified: String
  last_activity: String
  last_seen: String
  first_seen: String
  email_domain: String
  marital_status: String
  name: String
  viewed: [Viewed]
  owner:  User @relation(name: "OWNS_PROSPECT", direction: "IN")
  address:  Address @relation(name: "HAS_ADDRESS", direction: "OUT")
  companies:  [Company] @relation(name: "ASSOCIATED_WITH", direction: "OUT")
  properties:  [Interest]
  listings:  [Listing] @relation(name: "LISTS", direction: "OUT")
  recommendations(first: Int = 300): [Article] @cypher(statement: "MATCH (article:Article), (address:Address)<-[*]-(this) WHERE distance(article.location, Point({latitude:toFloat(address.lat), longitude:toFloat(address.lng)})) < 1000000 RETURN DISTINCT article")
#  teams: [Team] @relation(name: "BELONGS TO", direction: "OUT")
#  deals:  [Deal] @relation(name: "IS ASSOCIATED WITH", direction: "IN")
}

type Company implements Client{
  id: ID!
  lead_status: String
  name: String
  email: String
  created_at: Date
  address:  Address @relation(name: "HAS_ADDRESS", direction: "OUT")
  phone_numbers: [String]
  domain_name: String
  owner_assigned_date: String
  parent: String
  website_url: String
  contacts:  [Contact] @relation(name: "ASSOCIATED_WITH", direction: "IN")
  properties:  [Property] @relation(name: "HAS_INTEREST_IN", direction: "OUT")
#  deals:  [Deal] @relation(name: "IS ASSOCIATED WITH", direction: "OUT")
  listings:  [Listing] @relation(name: "LISTS", direction: "OUT")
  #  reviews: [Review] @relation(name: "REVIEWS", direction: "IN")
  #  categories: [Category] @relation(name: "IN_CATEGORY", direction: "OUT")
  fb_fans: [Contact] @relation(name: "FB_FANS", direction: "IN")
  team: [Team] @relation(name: "IS_MEMBER_OF", direction: "OUT")
  fb_page: String
  child_companies_num: String
  li_page: String
  lifecycle_stage: String
  twitter_bio: String
  web_technologies: [String]
  first_contact_create_date: String
  last_seen: String
  first_seen: String
  year_founded: String
  annual_revenue: String
  industry: String
  is_public: String
  contacted_times: String
  description: String
  employees_num: String
  first_contact_created_at: String
  hubspot_team: String
  last_activity: String
  last_contacted: String
  last_modified: String
  li_bio: String
  owner:  User @relation(name: "OWNS_PROSPECT", direction: "IN")
  owner_assigned_at: String
  pageviews_num: String
  phone: String
  sessions_num: String
  time_zone: String
  url: String
  mailed: [Mailed]
}

type Mail{
    id: ID!
    msgs: String
    timestamp: DateTime
}

type Mailed @relation(name: "MAILS") {
    from: Company
    to: Mail
    timestamp: DateTime
    action: Boolean
}

type Type{
    id: ID!
    name: String
}

type Strategy{
    id: ID!
    name: String
}

type Article {
    id: ID!
    title: String
    excerpt: String
    content: String
    source: String
    link: String
    location: Point
    event_time: DateTime
    categories: [Category] @relation(name: "IN_CATEGORY", direction: "OUT")
    viewed: [Viewed]
    shared: [Shared]
    opened_source: [OpenedSource]
    recommendations(first: Int = 300): [Contact] @cypher(statement: "MATCH (address:Address)<-[*]-(contact:Contact) WHERE distance(this.location, Point({latitude:toFloat(address.lat), longitude:toFloat(address.lng)})) < 1000000 RETURN DISTINCT contact")
}

type Viewed @relation(name: "VIEWED") {
    from: Contact
    to: Article
    timestamp: DateTime
    action: Boolean
}

type Interest @relation(name: "HAS_INTEREST_IN") {
    from: Contact
    to: Property
    action: Boolean
    associate: String
    event_time: DateTime
    id: String
    represents: String
    stage: String
    title: String
    type: String
    value: Int
}

type OpenedSource @relation(name: "OPENED_SOURCE") {
    from: Contact
    to: Article
    timestamp: DateTime
}

type Shared @relation(name: "SHARED") {
    from: Contact
    to: Article
    timestamp: DateTime
    outlet: String
}

type Category {
    id: ID!
    name: String
    articles: [Article] @relation(name: "IN_CATEGORY", direction: "IN")
    posts: [Post] @relation(name: "IN_CATEGORY", direction: "IN")
    companies: [Company] @relation(name: "IN_CATEGORY", direction: "IN")
}

type Post {
    id: ID!
    title: String
    meta: String
    keywords: [String]
    images: [String]
    content: String
    link: String
    event_time: DateTime
    viewed_post: [ViewedPost]
    shared_post: [SharedPost]
    categories: [Category] @relation(name: "IN_CATEGORY", direction: "OUT")
}

type ViewedPost @relation(name: "VIEWED_POST") {
    from: Contact
    to: Post
    timestamp: DateTime
}

type SharedPost @relation(name: "SHARED_POST") {
    from: Contact
    to: Post
    timestamp: DateTime
    outlet: String
}

type Property {
  id: ID!
  name: String
  property_type: String
  secondary_type: String
  additional_types: [String]
  address:  Address @relation(name: "HAS_ADDRESS", direction: "OUT")
#  parcels:  [Parcel] @relation(name: "INCLUDES PARCELS", direction: "OUT")
#  structures: [Structure] @relation(name: "INCLUDES STRUCTURES", direction: "OUT")
#  spaces:  [Space] @relation(name: "IS UNIT OF", direction: "IN")
  contacts:  [Contact] @relation(name: "HAS_INTEREST_IN", direction: "IN")
  companies:  [Company] @relation(name: "HAS_INTEREST_IN", direction: "IN")
  listings:  [Listing] @relation(name: "IS_LISTING_OF", direction: "OUT")
}

type Listing {
  id: ID!
  name: String
  lease_or_sale: String
  commission: String
  listing_expiration: String
  price: Int
  priceTerms: String
  noi: Int
  cap_rate: Float
  sale_conditions: [String]
  leaseTerm: String
  leaseType: String
  sfAvailMin: Int
  sfAvailMax: Int
  use: [String]
  availableOn: String
  availableWithin: String
  tenantName: String
  existingBuildout: String
  condition: String
  layout: String
  privateOffices: Int
  workStations: Int
  conferenceRooms: Int
  numPeopleMin: Int
  numPeopleMax: Int
  amenities: [String]
  spaceNotes: String
  spaceHighlights: [String]
  description: String
  images: [String]
  documents: [String]
  last_updated: Date
  square_footage: String
  added: String
  units: String
  parking_spaces: String
  pro_forma_noi: String
  properties:  [Property] @relation(name: "IS_LISTING_OF", direction: "IN")
#  space:  [Space] @relation(name: "IS LISTING OF", direction: "OUT")
  user:  User @relation(name: "IS_PRIMARY_AGENT_FOR", direction: "IN")
}

type Address {
  id: ID!
  postal_code:String
  street_address1:String
  street_address2:String
  lat: Float
  lng: Float

#  street_number: String
#  street_pre_direction: String
#  street_name: String
#  street_suffix: String
#  street_post_direction: String
#  unit_type: String
#  unit_number: String
#  formatted_street_address: String
#  city: String
#  state: String
#  zip_code: String
#  zip_plus_four_code: String
#  census_tract: String
#  house: Int
}

input Addressik {
    postal_code:String
    street_address1:String
    street_address2:String
    lat: String
    lng: String
}

type Team {
  id: ID!
  name: String
  slogan: String
  established: Date
}


type Query {

  client(filter: String="*"): [Client]
    @cypher(
        statement: "CALL db.index.fulltext.queryNodes('searchClient', $filter) YIELD node RETURN node"
  )
  company(filter: String="*", filter: String="*", orderByMe: String="owner.first_name asc"):[Company]

  contact(filter: String="*", filter: String="*", orderByMe: String="owner.first_name asc"): [Contact]

  interest:[Interest!]!
    @cypher(
        statement: "MATCH (contact:Contact)-[hii:HAS_INTEREST_IN]-(:Property) WHERE hii.id IS NOT NULL RETURN hii"
  )
  getClient:[Client]

  getClientCount: Int
    @cypher(
        statement: "MATCH (client:Client) RETURN count(client) as client_count"
    )
  getCompanyCount: Int
    @cypher(
        statement: "MATCH (company:Company) RETURN count(company) as company_count"
    )
  getContactCount: Int
    @cypher(
        statement: "MATCH (contact:Contact) RETURN count(contact) as contact_count"
    )
  getDealCount: Int
    @cypher(
        statement: "MATCH (deal:Deal) RETURN count(deal) as deal_count"
    )
  getListingCount: Int
    @cypher(
        statement: "MATCH (listing:Listing) RETURN count(listing) as listing_count"
    )
  getPropertyCount: Int
    @cypher(
        statement: "MATCH (property:Property) RETURN count(property) as property_count"
    )
  getUserCount: Int
    @cypher(
        statement: "MATCH (user:User) RETURN count(user) as user_count"
    )
  usersBySubstring(substring: String): [Client]
    @cypher(
      statement: "MATCH (u:User) WHERE u.name CONTAINS $substring RETURN u"
  )

  loginUser(name: String, pswd: String): [User]
  @cypher(
      statement: "MATCH (user:User {last_name: $name, pswd: $pswd}) RETURN user LIMIT 1"
  )
  loginContact(name: String, pswd: String): [Contact]
  @cypher(
      statement: "MATCH (contact:Contact {last_name: $name, pswd: $pswd}) RETURN contact LIMIT 1"
  )

}

type Mutation {
  readArticle(reader_id: String, article_id: String ): String
    @cypher(statement: "MATCH (contact:Contact {id: $reader_id }) MATCH (article:Article{id:$article_id}) MERGE (contact)-[read:VIEWED]->(article) RETURN id(read) as rel_id")

  createDeal(action: Int, amount: String, client_id: String, est_date: String, living: Int, property_id: String): Deal
    @cypher(statement: "MATCH (client:Client {id: $client_id }) MATCH (property:Property{id:$property_id}) MATCH (strategy:Strategy {id: $living }) MATCH (type:Type {id: $action }) CREATE (deal:Deal{stage: 'start', action: $action, amount: $amount, start_time: datetime(), est_date: datetime($est_date), living: $living}) MERGE (client)-[:HAS_INTEREST_IN]->(deal)-[:HAS_INTEREST_IN]->(property) MERGE (type)<-[:HAS_TYPE]-(deal)-[:HAS_STRATEGY]->(strategy) SET deal.id = toString(id(deal)) RETURN deal")

  updateContact(field: String, value: String, contactId: String): Contact

  mergeContactInterest(from: String, to: String): Interest
    @cypher(statement: "MATCH (contact:Contact{id: $from}) MATCH (property:Property{id: $to}) MERGE (contact)-[hii:HAS_INTEREST_IN]->(property) RETURN hii")

  createContact(address: Addressik, first_name: String, last_name: String, suffix: String, birthday: String, email: String, phone: String, mobile: String, linkedin_url: String,
        facebook_url: String, instagram_url: String, twitter_url: String, lead_status: String, lead_type: String, lead_date: String, lifecycle_stage: String,
        created_at: _Neo4jDateInput, last_modified: String, email_domain: String, marital_status: String): Contact
}


